#ifndef CUSTOM_LIT_PASS_INCLUDED#define CUSTOM_LIT_PASS_INCLUDED#include "Assets/Shaders/Common.hlsl"#include "Assets/Shaders/Surface.hlsl"#include "Assets/Shaders/Shadows.hlsl"#include "Assets/Shaders/CustomLight.hlsl"#include "Assets/Shaders/BRDF.hlsl"#include "Assets/Shaders/CustomLighting.hlsl"// #include "Assets/Shaders/CustomGI.hlsl"struct Attributes{    float4 positionOS : POSITION;    float2 baseUV : TEXCOORD0;    float3 normalOS : NORMAL;    //float4 tangentOS : TANGENT;    //GI_ATTRIBUTE_DATA    UNITY_VERTEX_INPUT_INSTANCE_ID};struct Varyings{    float4 positionCS : SV_POSITION;    float2 baseUV : TEXCOORD0;    float3 positionWS : TEXCOORD2;    float3 normalWS : TEXCOORD3;    //float3 viewDirWS : TEXCOORD4;    //GI_VARYINGS_DATA    UNITY_VERTEX_INPUT_INSTANCE_ID    //UNITY_VERTEX_OUTPUT_STEREO};// void InitializeInputData(Varyings input, out InputData inputData)// {//     inputData = (InputData)0;////     inputData.positionWS = input.positionWS;//     inputData.normalWS = input.normalWS;//     inputData.viewDirectionWS = input.viewDirWS;////     inputData.shadowCoord = 0;//     inputData.fogCoord = 0;//     inputData.vertexLighting = float3(0, 0, 0);//     inputData.bakedGI = float3(0, 0, 0);//     inputData.normalizedScreenSpaceUV = 0;//     inputData.shadowMask = float4(1, 1, 1, 1);// }//모든 인스턴스가 공유함TEXTURE2D(_BaseMap);SAMPLER(sampler_BaseMap);//인스턴싱을 위한 상수 버퍼UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)    UNITY_DEFINE_INSTANCED_PROP(float4, _BaseMap_ST)    UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)    UNITY_DEFINE_INSTANCED_PROP(float, _Cutoff)    UNITY_DEFINE_INSTANCED_PROP(float, _Metallic)    UNITY_DEFINE_INSTANCED_PROP(float, _Smoothness)UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)Varyings LitPassVertex(Attributes input){    Varyings output;    UNITY_SETUP_INSTANCE_ID(input);    UNITY_TRANSFER_INSTANCE_ID(input, output);    // UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);    // //TRANSFER_GI_DATA(input, output);    //    // VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz);    //    // output.positionCS = vertexInput.positionCS;    // output.uv = TRANSFORM_TEX(input.uv, _BaseMap);    //    // VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS);    // float3 viewDirWS = GetWorldSpaceViewDir(vertexInput.positionWS);    //    // // already normalized from normal transform to WS.    // output.positionWS = vertexInput.positionWS;    // output.normalWS = normalInput.normalWS;    // output.viewDirWS = viewDirWS;    //return output;    output.positionWS = TransformObjectToWorld(input.positionOS);    output.positionCS = TransformWorldToHClip(output.positionWS);    output.normalWS = TransformObjectToWorldNormal(input.normalOS);        float4 baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseMap_ST);    output.baseUV = input.baseUV * baseST.xy + baseST.zw;        return output;}float4 LitPassFragment(Varyings input) : SV_Target{    UNITY_SETUP_INSTANCE_ID(input);    // UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);    // CustomGI gi = GetGI(GI_FRAGMENT_DATA(input), surface);    // float3 color = GetLighting(surface, input.positionWS, GetBRDF(surface), gi);    //    // return float4(color, surface.alpha);    float4 baseMap = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.baseUV);    float4 baseColor = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);    float4 base = baseMap * baseColor;#if defined(_CLIPPING)    clip(base.a - UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Cutoff));#endif        Surface surface;    surface.position = input.positionWS;    surface.normal = normalize(input.normalWS);    surface.viewDirection = normalize(_WorldSpaceCameraPos - input.positionWS);    surface.color = base.rgb;    surface.alpha = base.a;    surface.metallic = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Metallic);    surface.smoothness = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Smoothness);#if defined(_PREMULTIPLY_ALPHA)    BRDF brdf = GetBRDF(surface, true);#else    BRDF brdf = GetBRDF(surface);#endif        float3 color = GetLighting(surface, brdf);    return float4(color, surface.alpha);}#endif