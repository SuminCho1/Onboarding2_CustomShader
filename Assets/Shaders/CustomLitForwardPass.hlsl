#ifndef CUSTOM_LIT_PASS_INCLUDED#define CUSTOM_LIT_PASS_INCLUDED#include "Assets/Shaders/Surface.hlsl"#include "Assets/Shaders/Shadows.hlsl"#include "Assets/Shaders/CustomLight.hlsl"#include "Assets/Shaders/BRDF.hlsl"#include "Assets/Shaders/CustomGI.hlsl"#include "Assets/Shaders/CustomLighting.hlsl"struct Attributes{    float4 positionOS : POSITION;    float2 baseUV : TEXCOORD0;    float3 normalOS : NORMAL;    //float4 tangentOS : TANGENT;    GI_ATTRIBUTE_DATA    UNITY_VERTEX_INPUT_INSTANCE_ID};struct Varyings{    float4 positionCS : SV_POSITION;    float2 baseUV : TEXCOORD0;    float3 positionWS : TEXCOORD2;    float3 normalWS : TEXCOORD3;    //float3 viewDirWS : TEXCOORD4;    GI_VARYINGS_DATA    UNITY_VERTEX_INPUT_INSTANCE_ID    //UNITY_VERTEX_OUTPUT_STEREO};Varyings LitPassVertex(Attributes input){    Varyings output;    UNITY_SETUP_INSTANCE_ID(input);    UNITY_TRANSFER_INSTANCE_ID(input, output);    TRANSFER_GI_DATA(input, output);    output.positionWS = TransformObjectToWorld(input.positionOS);    output.positionCS = TransformWorldToHClip(output.positionWS);    output.normalWS = TransformObjectToWorldNormal(input.normalOS);        float4 baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseMap_ST);    output.baseUV = TransformBaseUV(input.baseUV);     input.baseUV * baseST.xy + baseST.zw;        return output;}float4 LitPassFragment(Varyings input) : SV_Target{    UNITY_SETUP_INSTANCE_ID(input);        float4 base = GetBase(input.baseUV);#if defined(_CLIPPING)    clip(base.a - GetCutoff(input.baseUV));#endif        Surface surface;    surface.position = input.positionWS;    surface.normal = normalize(input.normalWS);    surface.viewDirection = normalize(_WorldSpaceCameraPos - input.positionWS);    surface.color = base.rgb;    surface.alpha = base.a;    surface.metallic = GetMetallic(input.baseUV);    surface.smoothness = GetSmoothness(input.baseUV);    surface.depth = -TransformWorldToView(input.positionWS).z;    surface.dither = InterleavedGradientNoise(input.positionCS.xy, 0);    #if defined(_PREMULTIPLY_ALPHA)    BRDF brdf = GetBRDF(surface, true);#else    BRDF brdf = GetBRDF(surface);#endif    CustomGI gi = GetGI(GI_FRAGMENT_DATA(input), surface);    float3 color = GetLighting(surface, brdf, gi);    color += GetEmission(input.baseUV);    return float4(color, surface.alpha);}#endif